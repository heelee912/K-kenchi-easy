<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>도시철도 뷰어 — 굵기 조절 · BBOX 조회 · GSON/GeoJSON 저장/불러오기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    #ui {
      position:absolute; top:10px; left:10px; z-index:1000; background:#fff;
      padding:10px 12px; border-radius:12px; box-shadow:0 2px 12px rgba(0,0,0,.15);
      width: 760px; max-height: 92vh; overflow: auto;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, sans-serif;
      font-size: 13px;
    }
    .row { display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap; }
    .row label { font-weight:600; }
    .btn { padding:6px 10px; border:1px solid #ccc; border-radius:8px; background:#f6f6f6; cursor:pointer; }
    .btn:hover { background:#efefef; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    #bboxes { width:100%; height:90px; }
    #query { border:1px dashed #bbb; border-radius:8px; padding:6px; background:#fff; white-space: pre-wrap; max-height:140px; overflow:auto; }
    #log { border:1px solid #ddd; border-radius:8px; padding:6px; background:#fafafa; max-height:200px; overflow:auto; }
    .legend { display:flex; flex-wrap:wrap; gap:8px; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:6px; background:#f2f2f2; }
    .swatch { width:18px; height:4px; display:inline-block; }
    input[type="number"] { width:70px; }
    .sep { height:1px; background:#eee; margin:8px 0; width:100%; }
  </style>
</head>
<body>
<div id="map"></div>

<div id="ui">
  <div class="row"><b>도시철도 지도</b> — 굵기를 직접 입력해 즉시 반영하고, <b>BBOX 조회</b> 또는 <b>GSON/GeoJSON</b> 파일을 저장·불러오기 할 수 있습니다.</div>

  <div class="row legend">
    <div class="chip"><span class="swatch" style="background:#2f6fff"></span>지하철</div>
    <div class="chip"><span class="swatch" style="background:#15a05a"></span>경전철</div>
    <div class="chip"><span class="swatch" style="background:#7a3cff"></span>모노레일</div>
    <div class="chip"><span class="swatch" style="background:#ff7b00"></span>트램</div>
    <div class="chip"><span class="swatch" style="background:#555555"></span>일반철도</div>
  </div>

  <div class="row">
    <label>굵기(px):</label>
    <label>지하철</label><input id="w_subway" type="number" min="0.5" step="0.1" value="2.0">
    <label>경전철</label><input id="w_light" type="number" min="0.5" step="0.1" value="2.4">
    <label>모노레일</label><input id="w_mono" type="number" min="0.5" step="0.1" value="2.2">
    <label>트램</label><input id="w_tram" type="number" min="0.5" step="0.1" value="2.4">
    <label>일반철</label><input id="w_rail" type="number" min="0.5" step="0.1" value="3.0">
    <button class="btn" id="apply">굵기 적용</button>
    <button class="btn" id="saveStyle">굵기 저장</button>
    <button class="btn" id="loadStyle">굵기 복원</button>
  </div>

  <div class="sep"></div>

  <div class="row"><b>BBOX로 Overpass 조회</b> — 각 줄에 <code>south,west,north,east</code>. 기본으로 두 범위가 들어가 있습니다.</div>
  <div class="row" style="align-items:stretch">
    <textarea id="bboxes" class="mono" placeholder="south,west,north,east 한 줄에 하나씩 입력"></textarea>
  </div>
  <div class="row">
    <label>엔드포인트:</label>
    <select id="endpoint">
      <option value="https://overpass-api.de/api/interpreter">overpass-api.de</option>
      <option value="https://overpass.kumi.systems/api/interpreter">kumi.systems</option>
      <option value="https://z.overpass-api.de/api/interpreter">z.overpass-api.de</option>
      <option value="https://overpass.openstreetmap.ru/api/interpreter">openstreetmap.ru</option>
    </select>
    <label><input type="checkbox" id="includeRail" checked> 광역전철/일반철(route=train) 포함</label>
    <button class="btn" id="run">모두 조회</button>
    <button class="btn" id="clear">로그 지우기</button>
  </div>

  <div class="sep"></div>

  <div class="row"><b>GSON/GeoJSON 저장·불러오기</b></div>
  <div class="row">
    <button class="btn" id="saveGeoJSON">현재 데이터 저장(.geojson)</button>
    <button class="btn" id="saveGSON">현재 데이터 저장(.gson)</button>
    <input type="file" id="gjFiles" accept=".geojson,.json,.gson" multiple>
    <button class="btn" id="showLocal">불러와서 표시</button>
  </div>

  <div class="sep"></div>

  <div class="row"><label>상태:</label><span id="status">대기 중</span></div>
  <div class="row"><label>현재 쿼리(마지막 BBOX):</label></div>
  <div id="query" class="mono"></div>
  <div class="row"><label>로그:</label></div>
  <div id="log" class="mono"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
  const map = L.map('map').setView([36.5, 127.9], 7);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const $bboxes = document.getElementById('bboxes');
  $bboxes.value = `34,126,39.1,130
33.2,126.0,33.6,127.0`;

  let layer;
  let currentFC = null; // 현재 지도에 올린 FeatureCollection
  const $status = document.getElementById('status');
  const $log = document.getElementById('log');
  const $query = document.getElementById('query');
  const $includeRail = document.getElementById('includeRail');

  const $w_subway = document.getElementById('w_subway');
  const $w_light  = document.getElementById('w_light');
  const $w_mono   = document.getElementById('w_mono');
  const $w_tram   = document.getElementById('w_tram');
  const $w_rail   = document.getElementById('w_rail');

  // 굵기 적용/저장/복원
  function applyWidths() { if (layer) layer.setStyle(styleByModeDynamic); }
  document.getElementById('apply').addEventListener('click', applyWidths);
  document.getElementById('saveStyle').addEventListener('click', () => {
    const obj = {
      w_subway: $w_subway.value, w_light: $w_light.value, w_mono: $w_mono.value, w_tram: $w_tram.value, w_rail: $w_rail.value
    };
    localStorage.setItem('urbanrail_widths', JSON.stringify(obj));
    alert('굵기를 저장했습니다.');
  });
  document.getElementById('loadStyle').addEventListener('click', () => {
    try {
      const obj = JSON.parse(localStorage.getItem('urbanrail_widths') || '{}');
      if (!obj || !obj.w_subway) return;
      $w_subway.value = obj.w_subway; $w_light.value = obj.w_light; $w_mono.value = obj.w_mono; $w_tram.value = obj.w_tram; $w_rail.value = obj.w_rail;
      applyWidths();
    } catch {}
  });

  function log(line, cls) {
    const time = new Date().toLocaleTimeString();
    const div = document.createElement('div');
    div.textContent = '[' + time + '] ' + line;
    if (cls) div.className = cls;
    $log.appendChild(div);
    $log.scrollTop = $log.scrollHeight;
  }
  function setStatus(text, cls) { $status.textContent = text; $status.className = cls || ''; }

  function buildQuery(bbox) {
    const railPart = $includeRail.checked ? '|train' : '';
    return `[out:json][timeout:180];
(
  way["railway"~"subway|light_rail|monorail|tram"](${bbox});
  relation["type"="route"]["route"~"subway|light_rail|monorail|tram${railPart}"](${bbox});
)->.all;
way(r.all)->.relways;
(
  way["railway"~"subway|light_rail|monorail|tram"](${bbox});
  way["railway"="rail"]["passenger"~"yes|main|permissive"](${bbox});
  way["railway"="rail"]["usage"~"main|branch"](${bbox});
)->.extra;
(.relways; .extra;)->.W;
.W out geom;`;
  }

  function pickMode(tags) {
    const railway = (tags.railway || '').toLowerCase();
    const route = (tags.route || '').toLowerCase();
    if (railway.includes('subway') || route.includes('subway')) return 'subway';
    if (railway.includes('light_rail') || route.includes('light_rail')) return 'light_rail';
    if (railway.includes('monorail') || route.includes('monorail')) return 'monorail';
    if (railway.includes('tram') || route.includes('tram')) return 'tram';
    if (route.includes('train') || railway.includes('rail')) return 'rail';
    return 'rail';
  }

  function styleByModeDynamic(f) {
    const mode = f.properties.__mode;
    const wSub = parseFloat($w_subway.value) || 2.0;
    const wLrt = parseFloat($w_light.value)  || 2.4;
    const wMon = parseFloat($w_mono.value)   || 2.2;
    const wTrm = parseFloat($w_tram.value)   || 2.4;
    const wRal = parseFloat($w_rail.value)   || 3.0;
    switch(mode) {
      case 'subway':     return { color:'#2f6fff', weight: wSub, opacity: 1 };
      case 'light_rail': return { color:'#15a05a', weight: wLrt, opacity: 1 };
      case 'monorail':   return { color:'#7a3cff', weight: wMon, opacity: 1 };
      case 'tram':       return { color:'#ff7b00', weight: wTrm, opacity: 1 };
      default:           return { color:'#555555', weight: wRal, opacity: 0.95 };
    }
  }

  function mergeWays(target, sourceElems) {
    const seen = new Set(target.map(f => f.properties.id));
    for (const el of sourceElems) {
      if (el.type !== 'way' || !el.geometry || el.geometry.length < 2) continue;
      if (seen.has(el.id)) continue;
      seen.add(el.id);
      const coords = el.geometry.map(p => [p.lon, p.lat]);
      const props = Object.assign({}, el.tags || {}, { id: el.id });
      const mode = pickMode(props);
      target.push({ type:'Feature', properties: Object.assign(props, {__mode: mode}), geometry:{ type:'LineString', coordinates: coords } });
    }
  }

  async function fetchOne(ep, bbox) {
    const Q = buildQuery(bbox);
    $query.textContent = Q;
    const url = ep + '?data=' + encodeURIComponent(Q) + '&nocache=' + Date.now();
    const res = await fetch(url);
    log('BBOX ' + bbox + ' → HTTP ' + res.status);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return res.json();
  }

  async function runAll() {
    const ep = document.getElementById('endpoint').value;
    const lines = $bboxes.value.split('\n').map(s => s.trim()).filter(Boolean);
    if (!lines.length) { alert('BBOX를 한 줄에 하나씩 입력하십시오.'); return; }
    if (layer) { map.removeLayer(layer); layer = null; }
    setStatus('조회 중', '');
    $log.innerHTML = '';

    try {
      const feats = [];
      for (const bbox of lines) {
        const data = await fetchOne(ep, bbox);
        const ways = (data.elements || []).filter(e => e.type === 'way');
        log('ways 수신: ' + ways.length + ' @ ' + bbox);
        mergeWays(feats, ways);
      }
      if (!feats.length) { setStatus('수신 0', 'err'); return; }
      currentFC = { type:'FeatureCollection', features: feats };
      layer = L.geoJSON(currentFC, {
        style: styleByModeDynamic,
        onEachFeature: (f, l) => {
          const nm = f.properties.name || f.properties.ref || '';
          if (nm) l.bindTooltip(nm, {sticky:true});
        }
      }).addTo(map);
      try { map.fitBounds(layer.getBounds(), { padding:[20,20] }); } catch(_) {}
      setStatus('완료: ' + feats.length + '개 선', 'ok');
      log('병합 완료: 총 ' + feats.length + '개 선');
    } catch (e) {
      setStatus('실패: ' + (e.message || e), 'err');
      log('에러: ' + (e.message || e), 'err');
    }
  }

  async function showLocal() {
    const input = document.getElementById('gjFiles');
    if (!input.files || !input.files.length) { alert('파일을 선택하십시오.'); return; }
    if (layer) { map.removeLayer(layer); layer = null; }
    $log.innerHTML = ''; setStatus('로컬 파일 로딩 중', '');

    try {
      const feats = [];
      for (const file of input.files) {
        const text = await file.text();
        let gj = JSON.parse(text);
        if (gj.type === 'FeatureCollection') {
          for (const f of gj.features || []) {
            if (!f || f.type !== 'Feature' || !f.geometry) continue;
            if (f.geometry.type !== 'LineString') continue;
            const props = f.properties || {};
            const mode = pickMode(props);
            f.properties = Object.assign({}, props, { __mode: mode, id: props.id || (props['@id'] || Math.random().toString(36).slice(2)) });
            feats.push(f);
          }
        }
      }
      if (!feats.length) { setStatus('표시할 선형 데이터가 없습니다.', 'err'); return; }
      currentFC = { type:'FeatureCollection', features: feats };
      layer = L.geoJSON(currentFC, {
        style: styleByModeDynamic,
        onEachFeature: (f, l) => {
          const nm = f.properties.name || f.properties.ref || '';
          if (nm) l.bindTooltip(nm, {sticky:true});
        }
      }).addTo(map);
      try { map.fitBounds(layer.getBounds(), { padding:[20,20] }); } catch(_) {}
      setStatus('완료: ' + feats.length + '개 선(로컬)', 'ok');
      log('로컬 파일 표시 완료: ' + feats.length + '개 선');
    } catch (e) {
      setStatus('실패: ' + (e.message || e), 'err');
      log('에러: ' + (e.message || e), 'err');
    }
  }

  function downloadJSON(obj, filename, mime='application/geo+json') {
    const blob = new Blob([JSON.stringify(obj)], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
  }

  function saveGeoJSON(ext) {
    if (!currentFC || !currentFC.features || !currentFC.features.length) {
      alert('저장할 데이터가 없습니다. 먼저 조회하거나 파일을 불러오십시오.'); return;
    }
    const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    const name = `urbanrail_${ts}.${ext}`;
    downloadJSON(currentFC, name, ext === 'gson' ? 'application/json' : 'application/geo+json');
  }

  document.getElementById('run').addEventListener('click', runAll);
  document.getElementById('clear').addEventListener('click', () => { $log.innerHTML=''; document.getElementById('status').textContent='대기 중'; });
  document.getElementById('showLocal').addEventListener('click', showLocal);
  document.getElementById('saveGeoJSON').addEventListener('click', () => saveGeoJSON('geojson'));
  document.getElementById('saveGSON').addEventListener('click', () => saveGeoJSON('gson'));
</script>
</body>
</html>
